[
  {
    "topic": "Functions",
    "text": "Given the code, what is the output?",
    "code": "void inc(int *p){ (*p)++; }\nint main(){ int x=4; inc(&x); printf(\"%d\", x); return 0; }",
    "options": [
      "4",
      "5",
      "Undefined behavior",
      "Compilation error"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "The pointer parameter allows modifying x via dereference; x becomes 5."
  },
  {
    "topic": "Functions",
    "text": "Which declaration defines an array of 3 pointers to functions taking (int,int) and returning int?",
    "options": [
      "int *f[3](int,int);",
      "int (*f[3])(int,int);",
      "int (*f)(int,int)[3];",
      "int f(int,int)*[3];"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "Brackets bind tighter than *, so f is an array of 3 elements, each a pointer to a function (int,int)->int."
  },
  {
    "topic": "Functions",
    "text": "What will the following print?",
    "code": "int add(int a,int b){return a+b;}\nint mul(int a,int b){return a*b;}\nint apply(int (*op)(int,int), int x,int y){return op(x,y);} \nint main(){ printf(\"%d %d\", apply(add,2,3), apply(mul,2,3)); }",
    "options": [
      "5 6",
      "6 5",
      "2 3",
      "Compilation error"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "Function pointer passed as callback; add(2,3)=5, mul(2,3)=6."
  },
  {
    "topic": "Functions",
    "text": "Which is a correct prototype to pass a 2D array with 4 columns to a function?",
    "options": [
      "void f(int a[][]);",
      "void f(int (*a)[]);",
      "void f(int a[][4]);",
      "void f(int **a);"
    ],
    "correct": [
      2
    ],
    "multiple": false,
    "explanation": "When passing a multidimensional array, all but the first dimension must be specified; column count is required."
  },
  {
    "topic": "Functions",
    "text": "What is printed?",
    "code": "int next_id(){ static int id=100; return ++id; }\nint main(){ printf(\"%d %d %d\", next_id(), next_id(), next_id()); }",
    "options": [
      "101 101 101",
      "101 102 103",
      "100 101 102",
      "Undefined order so unspecified values"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "The static variable retains its value across calls; sequence is 101, 102, 103. In printf the arguments are fully evaluated left-to-right in C23 and as unsequenced prior to C23 for side effects, but each call here is independent and yields increasing values; most compilers print 101 102 103. For interview safety: assume separate calls return increasing values."
  },
  {
    "topic": "Functions",
    "text": "What does this code print on a hosted implementation following the usual calling conventions?",
    "code": "int f(int x){ x += 2; return x; }\nint g(int x){ return f(x) + x; }\nint main(){ printf(\"%d\", g(3)); }",
    "options": [
      "5",
      "8",
      "6",
      "7"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "f(3)=5; g(3)=f(3)+3=8."
  },
  {
    "topic": "Functions",
    "text": "Which statement about passing pointers to a function is true?",
    "options": [
      "Pointers are passed by reference in C.",
      "Pointers are passed by value, but allow indirect modification of pointee.",
      "Passing a pointer always copies the entire pointed-to data.",
      "Passing a pointer to const allows modification of the pointee."
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "C uses pass-by-value. The pointer value (address) is copied, enabling modification of the object it points to."
  },
  {
    "topic": "Functions",
    "text": "Which is a valid declaration of a function that returns a pointer to int?",
    "options": [
      "int *f(void);",
      "int f*(void);",
      "int (*f)();",
      "*(int) f(void);"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "int *f(void) declares f as a function returning pointer to int."
  },
  {
    "topic": "Functions",
    "text": "What is the output?",
    "code": "int acc(int x){ static int s=0; s+=x; return s; }\nint main(){ printf(\"%d \", acc(2)); printf(\"%d\", acc(3)); }",
    "options": [
      "2 3",
      "2 5",
      "5 5",
      "Undefined"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "Static s accumulates across calls: first 2, then 5."
  },
  {
    "topic": "Functions",
    "text": "Which qsort comparator prototype is correct for sorting an array of int?",
    "options": [
      "int cmp(const void *a, const void *b);",
      "int cmp(int *a, int *b);",
      "int cmp(void **a, void **b);",
      "void cmp(const void *a, const void *b);"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "qsort expects int (*compar)(const void *, const void *). Inside, cast to const int* and compare."
  },
  {
    "topic": "Arrays",
    "text": "What is the size of 'arr' and '*arr' on a typical 64-bit system?",
    "code": "int arr[10]; printf(\"%zu %zu\", sizeof arr, sizeof *arr);",
    "options": [
      "40 4",
      "8 4",
      "40 40",
      "8 8"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "sizeof arr is 10 * sizeof(int) = 40; sizeof *arr = sizeof(int) = 4."
  },
  {
    "topic": "Arrays",
    "text": "Which expression refers to the element in row 2, column 3 of int a[3][4] (0-based)?",
    "options": [
      "*(*(a+2)+3)",
      "*(*(a+1)+2)",
      "*(a[2]+3)",
      "Both A and C"
    ],
    "correct": [
      3
    ],
    "multiple": false,
    "explanation": "a is array of rows; a+2 points to 3rd row; *(a+2) is pointer to its first element; +3 advances to column 3. Also a[2] is the 3rd row; a[2]+3 is its 4th element address; both dereference to the same element."
  },
  {
    "topic": "Arrays",
    "text": "Which function signature correctly receives a 2D array with 5 columns?",
    "options": [
      "void f(int a[][]);",
      "void f(int a[][5]);",
      "void f(int **a);",
      "void f(int (*a)[5]);"
    ],
    "correct": [
      1,
      3
    ],
    "multiple": true,
    "explanation": "Both 'int a[][5]' and 'int (*a)[5]' are valid parameter types for a 2D array with 5 columns."
  },
  {
    "topic": "Arrays",
    "text": "What is printed?",
    "code": "char s[8] = \"cat\"; strcat(s,\"nip\"); printf(\"%s\", s);",
    "options": [
      "catnip",
      "cat",
      "Undefined behavior",
      "Compilation error"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "s has room for 8 bytes; 'cat' uses 4 including NUL; concatenating 'nip' (4 incl. NUL) fits exactly."
  },
  {
    "topic": "Arrays",
    "text": "What is the value printed?",
    "code": "int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; int (*p)[4]=a+1; printf(\"%d\", (*p)[2]);",
    "options": [
      "3",
      "7",
      "6",
      "10"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "p points to row 1 (second row). (*p)[2] is element index 2 of that row \u2192 7."
  },
  {
    "topic": "Arrays",
    "text": "Choose the safe and correct way to copy a string literal into a writable buffer of size 16.",
    "options": [
      "char *s = \"example\"; strcpy(s, \"test\");",
      "char s[16]; strcpy(s, \"test\");",
      "char s[4]; strcpy(s, \"example\");",
      "char s[] = \"example\"; s[0] = 'E';"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "strcpy to s[16] is safe for \"test\". A: writes to read-only memory; C: overflow; D: modifying string literal storage is undefined."
  },
  {
    "topic": "Arrays",
    "text": "What is the output?",
    "code": "int a[5]={0,1,2,3,4}; int *p=a; printf(\"%d\", *(p+3));",
    "options": [
      "2",
      "3",
      "4",
      "Undefined"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "*(p+3) is a[3] which equals 3."
  },
  {
    "topic": "Arrays",
    "text": "Which statement about array-to-pointer decay is correct?",
    "options": [
      "In expressions, an array name usually converts to pointer to its first element.",
      "sizeof on an array parameter gives the full array size.",
      "Arrays always behave like pointers in all contexts.",
      "Taking &arr yields pointer to first element, not the whole array."
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "Array-to-pointer decay occurs in most expressions. sizeof(arr) on a true array yields total size; &arr is pointer to the whole array type."
  },
  {
    "topic": "Arrays",
    "text": "What will be printed?",
    "code": "char s[6] = \"abc\"; size_t n = sizeof s; printf(\"%zu\", n);",
    "options": [
      "3",
      "4",
      "5",
      "6"
    ],
    "correct": [
      3
    ],
    "multiple": false,
    "explanation": "The array has static size 6 bytes regardless of content."
  },
  {
    "topic": "Arrays",
    "text": "Which call is appropriate for memmove with overlapping regions inside the same buffer?",
    "options": [
      "memcpy(dst, src, n);",
      "memmove(dst, src, n);",
      "strcpy(dst, src);",
      "strncpy(dst, src, n);"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "memmove handles overlapping regions; memcpy does not guarantee correctness with overlap."
  },
  {
    "topic": "Pointers",
    "text": "Choose the correct interpretation of '*p++'.",
    "options": [
      "Increment the value pointed to by p and then use it.",
      "Increment pointer p after dereferencing its current location.",
      "Increment pointer p before dereferencing.",
      "Undefined behavior in standard C."
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "Postfix ++ binds tighter than *, so *(p++) dereferences the current location, then increments p."
  },
  {
    "topic": "Pointers",
    "text": "Given 'int a[5]; int *p=a;' which is true?",
    "options": [
      "&*p == p",
      "*&p == p",
      "p[2] equals *(p+2)",
      "All of the above"
    ],
    "correct": [
      3
    ],
    "multiple": false,
    "explanation": "Dereference and address operators cancel when valid; and array indexing via p[2] equals *(p+2)."
  },
  {
    "topic": "Pointers",
    "text": "Select the declaration(s) for a pointer to a 4-int array.",
    "options": [
      "int *p[4];",
      "int (*p)[4];",
      "int p(*[4]);",
      "int **p[4];"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "int (*p)[4] is a pointer to an array of 4 int; int *p[4] is array of 4 pointers."
  },
  {
    "topic": "Pointers",
    "text": "What is printed on a 64-bit system?",
    "code": "int x=10; int *p=&x; printf(\"%zu %zu\", sizeof p, sizeof *p);",
    "options": [
      "8 4",
      "4 8",
      "8 8",
      "4 4"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "Pointer size is 8 bytes on 64-bit; sizeof *p is sizeof(int)=4."
  },
  {
    "topic": "Pointers",
    "text": "Which statement about pointer subtraction is correct?",
    "options": [
      "Subtracting two pointers to elements of the same array yields the element distance.",
      "Pointer subtraction yields the byte difference always.",
      "Subtracting pointers to different arrays is well-defined.",
      "Pointer subtraction is not allowed in C."
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "Defined only for pointers within the same array (or one past the end). Result is element count."
  },
  {
    "topic": "Pointers",
    "text": "What is the effect of '++*p' ?",
    "options": [
      "Increment p, then dereference.",
      "Increment the value pointed to by p.",
      "Same as *p++",
      "Undefined behavior"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "Prefix ++ binds to *p as an operand; it increments the pointee value."
  },
  {
    "topic": "Pointers",
    "text": "Which statement about void* is true in ISO C?",
    "options": [
      "Pointer arithmetic on void* is standard and steps by 1 byte.",
      "Pointer arithmetic on void* is not defined by standard C.",
      "void* cannot be converted to other object pointers.",
      "void* cannot hold any object pointer."
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "ISO C does not define arithmetic on void*; GNU C allows it as an extension."
  },
  {
    "topic": "Pointers",
    "text": "Will this function modify the caller's pointer variable p?",
    "code": "void reset(int *p){ p = NULL; }\nint main(){ int x=5; int *q=&x; reset(q); /* is q NULL here? */ }",
    "options": [
      "Yes, q becomes NULL.",
      "No, q remains unchanged.",
      "Depends on compiler",
      "Undefined behavior"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "Parameter p is a copy (pass-by-value). Setting p=NULL doesn't change q. Use int ** to modify the pointer itself."
  },
  {
    "topic": "Pointers",
    "text": "Which declaration is a pointer to function returning int and taking (const char*)?",
    "options": [
      "int *f(const char*);",
      "int (*f)(const char*);",
      "int f*(const char*);",
      "int (*f*) (const char*);"
    ],
    "correct": [
      1
    ],
    "multiple": false,
    "explanation": "Parentheses around *f make f a pointer to function."
  },
  {
    "topic": "Pointers",
    "text": "Given 'int a[3]={1,2,3}; int *p=a; int *q=&a[2];' what does 'q - p' evaluate to?",
    "options": [
      "2",
      "8 (bytes)",
      "Implementation-defined",
      "Undefined"
    ],
    "correct": [
      0
    ],
    "multiple": false,
    "explanation": "q-p is the number of elements between pointers to the same array: 2."
  }
]